Linux Resources:

* https://linuxjourney.com/
[excellent free respource]



-------------------------------------------------------
To upgrade/update, write in terminal:

apt update -y && apt upgrade -y && apt dist-upgrade -y

[hat tip: Get Cyber (https://www.youtube.com/watch?v=_mvPASM89a0)]

---------------------------------------------------------
Installing Packages (programs, apps, etc.)

[from: Network Chuck - apt, dpkg, git, Python PiP (Linux Package Management) // Linux for Hackers // EP 5 ; https://www.youtube.com/watch?v=vX3krP6JmOY&list=PLIhvC56v63IJIujb5cyE13oLuyORZpdkL&index=6]

* dpkg - will not find packages by name online (you need to download them first); it will also not automatically download an install the dependencies you need for the package you want


* apt (advanced package tool) - the apt command will search for packages by name in its repository; you can also direct it to other repositories and it can download from them; it will install the package and install all its dependencies; better to use apt command when possible
- Before using apt to install new package always give the command:
  sudo apt update
  this will have apt communicate with its repository so it will have the most up-to-date list of packages for you to draw from.
- Then use this command to have apt search its repository and install the package you desire:
  sudo apt install <NAME_OF_PACKAGE>
  for example: sudo apt install pidgin
- then you can run the package by typing its name as the command, e.g. pidgin 

* sudo apt edit-sources
- to see a list of the repositories apt automatically checks (and edit the list)
  choose an editor from the list of editors it gives you
* apt list
- this will list all packages in the repositories that apt is checking
* apt list --installed 
- this will list all packages installed on your system (you can '| grep' to search for a specific package)
* sudo apt show <NAME_OF_A_PACKAGE>
- will tell you about a package
* sudo apt search <NAME_OF_A_PACKAGE>
* sudo apt remove <NAME_OF_A_PACKAGE> 
- will delete package but not your user configs and data; if you reinstall the package you will be able to use them
* sudo apt purge <NAME_OF_A_PACKAGE> 
- will remove package and all associated data
* sudo apt update && sudo apt upgrade
- will check the repositories for updates to all your installed packages and if it finds updates for them it will upgrade them using those updates
* sudo apt update && sudo apt full-upgrade
- will do the same as 'sudo apt update && sudo apt upgrade' but will also remove any dependencies, etc. that are no longer needed for the upgraded packages

Also see Network Chuck's info (in the cited video) on the following package managers:
* aptitude
* snapd

Some program languages have their own package managers for the packages written in those languages:
PiP - this is a Python language package manager for certain packages written in Python
RubyGems (uses command 'gem install') - this is a Ruby language package manager for certain packages written in Ruby

Installing packages from GitHub
-------------------------------
* First make sure 'git' is installed on your system. If it is not, install it using:
sudo apt install git
* If git is installed, you can now install packages directly from GitHub by using the command:
git clone <URL_OF_GitHub_REPOSITORY_CONTAINING_PACKAGE_THAT_YOU_WANT>
(example: git clone https://github.com/fleetcaptain/Turbolist3r)
The package will be placed in the directory you are presently in.
* Now, check the folder that was downloaded and see if there is a "requirements.txt" document in it. If there is you can download the requirements as follows. If the executable is a .py (Python) program, you can use the following command:
- pip install -r requirements.txt (if you have python2)
- pip3 install -r requirements.txt (if you have python3)
* To run the python script the command is:
- python <NAME_OF_SCRIPT>.py <ARGUMENTS> (if you have python2)
- python3 <NAME_OF_SCRIPT>.py <ARGUMENTS> (if you have python3)

---------------------------------------------------------
In the command line prompt the presence of ~ represents that a user is now in their home directory.
The command 'cd ~' will return you to your home directory from wherever you are in the file system.

------------------------------------------------

Linux File System
-----------------
* in Linux everything is treated as a file (including devices)
* files are case sensitive
* can contain up to 255 characters
* can contain any character (including whitespace) except /
* extensions are not needed/interpreted; they are only for user convenience

Every file is part of a path - the unique location of the file represented by alphanumeric names of parent directories and the file divided by /
The first / represents root directory and the following slashes delimit nested directories under root and finally the file.

[from: Linux Tutorials | The File System | GeeksforGeeks ; https://www.youtube.com/watch?v=JwgTeXfQdIg&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=5]

In the Linux FHS [File Hierarchy Structure/Filesystem Hierarchy Standard] all files are listed under root (/) even if they are found on different physical/virtual machines.
Only root (/) directory has no parent.
Only the root user can write to the root directory.
The root user's home directory is: /root (note: / != /root)

A "home directory" is the main repository for a user's file's (including their configuration file). When a user logs into a system, by default they usually start off in their home directory. [In the command line prompt the presence of ~ represents that a user is now in their home directory.]
As stated above: the root user's home directory is: /root.
Other users' home directories are by default created with the /home directory.

[from: Linux Tutorials | Linux Directory Structure | GeeksforGeeks ; https://www.youtube.com/watch?v=yWiUPWHljWg&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=6]

-------------------------------------------------------
Comparing Files
----------------
cmp - compares two files byte by byte to see if they are identical 
syntax: cmp <FIRST_FILENAME> <SECOND_FILENAME>
if there is a mismatch, the location of first instance of mismatch is identified by byte number and line number
if files are identical nothing happens; the terminal returns to the prompt

comm - compares two files that have already been sorted
syntax: comm <FIRST_FILENAME> <SECOND_FILENAME>
it displays three columns; the first column is lines unique to first file; the first column is lines unique to second file; the third column is lines identical in both files

diff - compares files and tells you which lines have to be changed in order to make files identical.
syntax: diff <FIRST_FILENAME> <SECOND_FILENAME>
The output uses the following symbols to instruct what steps to take to make the files identical:
* a - add
* c - change
* d - delete
The arrangement of the output on the terminal screen is confusing at first. See the video cited below where parsing the output is explained.

[from: Linux Tutorials | cmp, diff and comm commands | GeeksforGeeks ; https://www.youtube.com/watch?v=0k6obEKGTyk&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=19]
-------------------------------------------------------
tee - duplicates the output received from a command sending one stream to the terminal and the other into a file (requires pipe |)
syntax: <COMMAND> | tee <FILENAME>
example: ls | tee list_of_files_in_directory 
[from: Linux Tutorials | Pipe and tee | GeeksforGeeks ; https://www.youtube.com/watch?v=19mmVar-s5Y&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=21]
-------------------------------------------------------
In order to print lines in the middle of a file you can combine 'head' and 'tail' commands using the pipe (|) command. For example, if you wanted to print lines 5-10 of a 20 line file you would use the following command:
head -n 10 <FILENAME> | tail -n 6
The command first instructs the computer to pull the first 10 lines of the file; those ten lines are then piped into the tail command which instructs the computer to pull the last 6 lines of those 10 lines (i.e. lines 5-10) and print those last 6 lines.
[From: Linux Tutorials | Print line between M and N lines head and tail combined | GeeksforGeeks ; https://www.youtube.com/watch?v=tMXF-YKyP0w&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=23]
--------------------------------------------------------
For the 'sort' command, the -k [#] option tells the terminal which "column" to sort on (the default delimeter is a blank space; but you can use -d " " to tell it to sort on something else [e.g. -d "|" will tell it to treat each pipe as the divider between columns])
the -c command tells the terminal to check if the file is sorted and tell you wherever the sort is out of order
there is other important things in the video - check it out
[from: Linux Tutorials | sort command GeeksforGeeks ; https://www.youtube.com/watch?v=fEx5rnbDKO4&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=27]
---------------------------------------------------------
The 'tr' command will "translate" characters in a file from one set of characters to another. For example "[a-z]" "[A-Z]" will change all lower-case characters to upper-case.
See here for a tutorial:
Linux Tutorials | tr command | GeeksforGeeks ; https://www.youtube.com/watch?v=iNWdEWWYo50&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=28
---------------------------------------------------------
The 'stat' command allows you to check all the timestamps on a file.
access time - the last time the file was read
modification time - the last time the contents of the file were modified
change time - the last time the file's metadata (e.g. size and type) were changed
syntax: stat <FILENAME>
The 'touch' command can create a file. It can also change a file's timestamps (access time [-a] or modification time [-m]). You can choose an arbitrary time using: -d "YYYY-DD-MM HH:MM:SS".

[From: Linux Tutorials | touch command | GeeksforGeeks ; https://www.youtube.com/watch?v=tpUyBbD4LQE&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=29]
--------------------------------------------------------------------------------------------------------------------------------------------------------
Compressing and archiving files and directories
-----------------------------------------------
archiving (tar utility) - takes multiple files/directories and turns them into one file (.tar)
compressing (gzip utility) - takes a file and compresses it to have a smaller size (.gz)

You can compress a regular file or an archive (.tar) file.

tar syntax
tar -cf tarfile.tar file1 file2 (archives file1 and file2 into a tar archive file called tarfile.tar)
tar -xf tarfile.tar (extracts file1 and file2 from the tar archive called tarfile.tar)

gzip syntax:
gzip file1.txt (compresses file1 into file1.txt.gz)
gunzip file1.txt.gz (decompresses file1.txt.gz back to file1.txt)

To check how much disk usage is taken up by a file use the 'du' command
syntax:
du <FILENAME>
You can also use these arguments:
-h (file size in human readable format)
-hc (file sizes and total size)
[From: Linux Tutorials | Compressing and Archiving Files in Linux | tar and zip commands | GeeksforGeeks; https://www.youtube.com/watch?v=KucqplDh7LI&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=31]

Note: gzip only can compress one file at a time. tar only archives multiple files into one file, it does not compress. You must first tar and then gzip the tar if you want to compress multiple files at once.
However, multiple files can be archived and compressed in the terminal using 'zip' to do both at once.
syntax: 
* zip <NAME_OF_ZIP_FILE_BEING_CREATED> <NAME_OF_FIRST_FILE_BEING_ZIPPED> <NAME_OF_SECOND_FILE_BEING_ZIPPED>
The resulting file will have a .zip extension.
To unzip a zipped file, use the syntax: unzip <NAME_OF_ZIPPED_FILE>.

Another option for archiving files is rar. Rar files are both archived and compressed. rar files have a .rar extension.
The syntax is:
rar a <NAME_OF_RAR_FILE_BEING_CREATED> <NAME_OF_FIRST_FILE_BEING_RARRED> <NAME_OF_SECOND_FILE_BEING_RARRED> [the a parameter is to add the archive]
unrar e <NAME_OF_RAR_FILE_BEING_EXTRACTED> [the e parameter is to extract the files from the archive]
[From: LetsDefend]
--------------------------------------------------------------------------------------------------------------------------------------------------------
Wildcards can be used with most commands in Linux (such as ls or cp).
Wildcards can be used at the beginning, middle, or end of search string.
* = 0, 1, or many characters
? = only 1 character
[ ] - the is called a character class. You can put a list of characters in the brackets and if the searched for string matches anyone of the characters the string will be found. For example, a search for wa[nt] will return wan and wat. This search only matches for one character.
[^ ] - this syntax will negate a character class (e.g. ab[^cd] will not return abc or abd but will return abe).
[ - ] - this syntax allows a search for a range (e.g. ab[h-k] will return abh, abi, abj, and abk).

Note: you can combine wildcards (e.g. *[c-f]).
\ - this is an "escape" character it allows you to search for wildcard characters as regular characters and not wildcards (e.g. *\?, will return all files that end with ?)

[from: Linux Tutorials | Wildcards and Pattern Matching | GeeksforGeeks ; https://www.youtube.com/watch?v=LH4eF75Z_7U&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=34]
--------------------------------------------------------------------------------------------------------------------------------------------------------
The YouTube video cited below explains the concepts of the three standard file in Linux: Standard Input, Standard Output and Standard Error. These files function as follows:
* stdin - from the keyboard
* stdout - to the screen
* stderr - also to the screen
The video discusses the redirection of these three files so that:
* the stdout can be sent to a file (using: > <FILENAME> [which will overlay what is already in the file] or >> [which will append to what is already in the file])
* the stdin can be drawn from a file (using: < <FILENAME>)
* the stderr can be separated from the stdout (so it does not clutter the screen) and sent to a file (using: 2><FILENAME>)

stdin = 0 [file descriptor]
stdout = 1 [file descriptor]
stderr = 2 [file descriptor]

[from: Linux Tutorials | Redirection - The three standard files in Linux | GeeksforGeeks ; https://www.youtube.com/watch?v=SP0gDpamofY&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=39]

--------------------------------------------------------------------------------------------------------------------------------------------------------
The 'which' command allows you to determine which file the commands you are running in the terminal are drawing their binaries from (e.g. 'which ls' might return /usr/bin/ls).
[From: Network Chuck ; the Linux File System explained in 1,233 seconds // Linux for Hackers // EP 2 ; https://www.youtube.com/watch?v=A3G-3hp88mo&list=PLIhvC56v63IJIujb5cyE13oLuyORZpdkL&index=2]

The 'apropros' command allows you to search for commands by keyword. It searches the commands and their documentation.
[From: Network Chuck - HELP!! (for when you suck at Linux) // Linux for Hackers // EP3 ; https://www.youtube.com/watch?v=Y17KTiJLcyQ&list=PLIhvC56v63IJIujb5cyE13oLuyORZpdkL&index=3]
--------------------------------------------------------------------------------------------------------------------------------------------------------
Managing Users
--------------
[From: Network Chuck - sudo = POWER!! (managing users in Linux) // Linux for Hackers // EP4 ; https://www.youtube.com/watch?v=jwnvKOjmtEA&list=PLIhvC56v63IJIujb5cyE13oLuyORZpdkL&index=4]

* whoami
* groups - this command will list all the groups the user account you are in is a member of
* adduser <NAME_OF_USER_ACCOUNT_BEING_CREATED> <--usually you will create new user accounts with this command; it will walk you through the full creation of the new user account and automatically creates a home directory for the account
* useradd <NAME_OF_USER_ACCOUNT_BEING_CREATED> <--this one does not do as much; it will create the account but you will have to add password and home directory later (see 'usermod')
* usermod - allows you to modify an existing user account, including adding the user to groups (syntax: sudo usermod -aG <GROUP_NAME> <USER_NAME>)
[Removing a user from a group, syntax: sudo gpasswd -d <USER_NAME> <GROUP_NAME>]
* cat /etc/passwd - list of users
* su - <NAME_OF_USER_BEING_SWITCHED_TO>
The 'su -' command is used for changing users (su = switch user). [Note: using 'su -' without giving a user name will default to switching to the root user.] Typing 'exit', 'logout' or CTRL-D will return you to your original user account.
* sudo - stands for "super user do" change to root user for one command then it switches back
The list of users who have sudo rights is found in the sudoers file. The safe, best practice way to edit this file is using the command: 'sudo visudo'
* userdel - delete a user
* groupadd - add a group (list of groups stored in /etc/group; every user automatically is assigned their own group which is the same as their username; they can also be assigned to created groups)
* groupdel - delete a group (syntax: sudo groupdel <GROUP_NAME>)
--------------------------------------------------------------------------------------------------------------------------------------------------------
Linux Services (called daemons)

[from: Network Chuck - start, stop, restart Linux services (daemon HUNTING!!) // Linux for Hackers // EP 6 ; https://www.youtube.com/watch?v=wOWhfNB_r-0&list=PLIhvC56v63IJIujb5cyE13oLuyORZpdkL&index=7]
- Linux services (called daemons) can be identified by the letter "d" appended to their name (e.g. the service that provides SSH is called sshd)
- systemd - the so-called master daemon that all the other services (in this context referred to as as units), "fork" out from (a process tree). Systemd is an initialization system and service manager for all other services.

commands:
systemctl is the basis for the commands to control Linux services. It interacts with systemd which contols Linux services (daemons).

* sudo systemtemctl stop <NAME_OF_SERVICE>
stop a Linux service from running
* sudo systemtemctl start <NAME_OF_SERVICE>
start a Linux service that has been stopped or not yet started
* sudo systemtemctl restart <NAME_OF_SERVICE>
stop and restart a Linux service (this is often used when a service is not working properly; often restarting it will fix the problem)
* sudo systemtemctl reload <NAME_OF_SERVICE>
reloads services configuration without restarting; not available for all services; you can also use the command 'sudo systemtemctl reload-or-restart <NAME_OF_SERVICE>' and it will reload if it can and if not it will restart
* sudo systemtemctl disable <NAME_OF_SERVICE>
will prevent service from starting at boot; however, if service is running now it will continue running
* sudo systemtemctl enable <NAME_OF_SERVICE>
will cause the service to start at boot
* sudo systemtemctl status <NAME_OF_SERVICE>
check status of a Linux service 
- if under "Active:" it says "inactive (dead)" the service is stopped; if it says "active (running) the service is running
- if a service is running but has been disabled from starting at boot it will have "disabled" listed under "Loaded"
* sudo systemctl list-units
lists all active services (you can '| grep <NAME_OF_SERVICE>' to pull out specific service you are interested in)
* sudo systemctl list-units --all
lists active and inactive services
* sudo systemctl list-unit-files
lists the files of all services on the system; including files that have not yet been parsed and loaded into memory
* sudo journalctl -xe
- journalctl is the logs for systemd; it enables you to troubleshoot issues with services; this command will let you view all the logs; you can grep for a particular service that you are interested in
--------------------------------------------------------------------------------------------------------------------------------------------------------
[From: Network Chuck - KILL Linux processes!! (also manage them) // Linux for Hackers // EP 7 ; https://www.youtube.com/watch?v=LfC6pv8VISk&list=PLIhvC56v63IJIujb5cyE13oLuyORZpdkL&index=10]

commands:
* ps 
shows running processes; however default is just to show processes running in the terminal you are entering the command from - you will usually need to add arguments

* ps --help
will show you ps help options; you have to then choose from them to see a help guide

* ps -aux
the arguments -aux are the most commonly used arguments for ps:
a = show processes from all users
u = list the user that each process belongs to
x = show processes from everywhere (not just the processes executed from the terminal you are entering the command from)
you can '| grep' for a particular process (not every system has pgrep installed)

* pgrep <NAME_OF_PROCESS>
this combines ps with grep to find a particular process and return its PID (process ID) - which is necessary for killing a process (Note: not every system has pgrep installed; you might need to do: ps -aux | grep <NAME_OF_PROCESS>)

* kill <PID (PROCESS ID)>
stops a process; used to stop unresponsive processes

<CTRL>-Z - puts process that is running in foreground (see below) of your terminal to sleep (i.e. stops it [stop here means pause])
<CTRL>-C - kills process that is running in foreground (see below) of your terminal (i.e. ends it permanently)

* top
shows all currently running processes sorted in real time by CPU usage
hitting 'q' exits top

* htop
the same information as top but with a nicer display
hitting 'q' exits htop

Processes can either be:
foreground processes - these can be interacted with
background processes - these must be first switched to foreground to interact with them [Note: you may be able to see data being generated from a background process - you just cannot interact with the process (e.g. you cannot stop or kill it).]
* bg <JID> (see below under 'jobs' for info on JID)
background a process
* fg <JID>

* jobs
shows a list of all running and sleeping (called stopped [meaning paused]) jobs in your terminal, and the identifying number (JID [Job ID] - not the same as the PID) that has been assigned to them


Linux CLI
---------

Basics
------

------------------------------------------
Commands must be separated from arguments (e.g. -a) and file names by at least one space or tab; but multiple spaces or tabs is not a problem.
Multiple arguments can be combined in one dash (-) with no spaces, e.g. -l -a -c = -lac
You can run more than one command per line if you use a semicolon (;), e.g.:
> cd;pwd

The 'type' command will tell you where the script for a Linux CLI command (usually written in C language) is found (internal [in the shell itself] or external [in a file path]), for example:
> type ls
ls is hashed (/bin/ls)
> type cd
cd is a shell builtin

[hat tip: Linux Tutorials | Command Usage | GeeksforGeeks https://www.youtube.com/watch?v=L5_ZzpR9jaU&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=4]

You may be unable to use the backspace key in the terminal to correct a typo.
If you try Backspace you may get ^?. In order to fix typos, use the Delete key or CTRL-c.
If the line has many mistakes it may be easier to kill the whole line by pressing CTRL-U. This will erase the whole line and you can start over.
If a program is stuck in an infinite loop pressing Ctrl-c will stop the program and return to prompt.
Some commands that require an argument will also create a problem if one forgets to add the argument. For example, if you type 'cat' with no filename and press enter the terminal will move the cursor to the next line but no output or prompt will appear. Pressing CTRL-c or CTRL-d will bring back the prompt.
If the Enter key is not working try: CTRL-j or CTRL-m.
[hat tip: Linux Tutorials | Commands in Linux when things go wrong | GeeksforGeeks ; https://www.youtube.com/watch?v=7zG1RAVcrKM&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=9]

who - displays list of users currently logged on to the system and information about them (e.g. login time)
whoami - displays the name of the user logged into the terminal
uname - displays information about the OS (use -r to get version info too ; use -n to get host name)
tty - displays the filename of the terminal connected to stdin (standard input)
stty - is used to display current terminal line settings (how many lines are shown) and to change those settings
[hat tip: Linux Tutorials | About the user and the terminal | GeeksforGeeks ; https://www.youtube.com/watch?v=WnjofnvIIvg&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=11]

cal - prints calendar on the terminal
date - displays the current date and time
echo - prints given text on the terminal
printf - prints text in a formatted way on the terminal
[hat tip: Linux Tutorials | General Purpose Utilities | GeeksforGeeks ; https://www.youtube.com/watch?v=g6cPFj9ptdc&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=12]
-----------------------------------------

[hat tip: https://tryhackme.com/room/zeekbro]

View the command history:
ubuntu@ubuntu$ history

Execute the 10th command in history:
ubuntu@ubuntu$ !10

Execute the previous command:
ubuntu@ubuntu$ !!

Read File
---------
Read sample.txt file:
ubuntu@ubuntu$ cat sample.txt

Read the first 10 lines of the file:
ubuntu@ubuntu$ head sample.txt

Read the last 10 lines of the file:
ubuntu@ubuntu$ tail sample.txt

Find & Filter
-------------
Cut the 1st field:
ubuntu@ubuntu$ cat test.txt | cut -f 1

Cut the 1st column:
ubuntu@ubuntu$ cat test.txt | cut -c1

Filter specific keywords:
ubuntu@ubuntu$ cat test.txt | grep 'keywords'

Sort outputs alphabetically:
ubuntu@ubuntu$ cat test.txt | sort

Sort outputs numerically:
ubuntu@ubuntu$ cat test.txt | sort -n

Eliminate duplicate lines:
ubuntu@ubuntu$ cat test.txt | uniq

Count line numbers:
ubuntu@ubuntu$ cat test.txt | wc -l

Show line numbers
ubuntu@ubuntu$ cat test.txt | nl

Advanced
--------
Print line 11:
ubuntu@ubuntu$ cat test.txt | sed -n '11p'

Print lines between 10-15:
ubuntu@ubuntu$ cat test.txt | sed -n '10,15p'

Print lines below 11:
ubuntu@ubuntu$ cat test.txt | awk 'NR < 11 {print $0}'

Print line 11:
ubuntu@ubuntu$ cat test.txt | awk 'NR == 11 {print $0}'

Use Case	                                           Description
--------                                             ----------- 
sort | uniq                                     Remove duplicate values.

sort | uniq -c                                  Remove duplicates and count the number of occurrences for each value.

sort -nr                                        Sort values numerically and recursively.

rev                                             Reverse string characters.

cut -f 1                                        Cut field 1.

cut -d '.' -f 1-2                               Split the string on every dot and print keep the first two fields.

grep -v 'test'                                  Display lines that  don't match the "test" string.

grep -v -e 'test1' -e 'test2'                   Display lines that don't match one or both "test1" and "test2" strings.

file                                            View file information.

grep -rin Testvalue1 * | column -t | less -S    Search the "Testvalue1" string everywhere, organise column spaces and view the output with less.

[hat tip: https://tryhackme.com/room/zeekbro]
-----------------------------------------------------------------------------------------------------------------------------------------------------------
Use case for 'rev' command in Linux CLI:
The 'rev' command reverses the text. So the word "hello" becomes "olleh".
In the TryHackMe room "Zeek Exercises" [https://tryhackme.com/room/zeekbroexercises ; Task 2, Question 3] it was necessary to find all the unique domain names in a file using the CLI.
The CLI can use the 'uniq' command to list each unique domain.
The problem is that each domain appeared many times with various sub-domains of varying lengths and textual content. There could also have been sub-sub-domains delineated by ".". How does one tell the computer to only look at the domain and TLD when determing uniqueness?
The hint TryHackMe gave for this question used rev as part of the command. Basically, you reverse the text and then use "cut -d '.' -f 1-2" to pull out only the TLD and domain names. You have avoided the variability in the sub-domains and can be sure that you are only extracting the TLD and domain. Then you rev the data back into the proper order and list each unique occurence.
------------------------------------------------------------------------------------------------------------------------------------------------------------
Learning Linux CLI (aka Terminal aka Bash)
------------------------------------------
https://ubuntu.com/tutorials/command-line-for-beginners#1-overview
https://www.hackthebox.com/blog/learn-linux
https://www.freecodecamp.org/news/the-linux-commands-handbook/
[hat tip: https://www.reddit.com/r/tryhackme -- WRWhizard]
-------------------------------------------------------------------------------------------------------------------------------------------------------------
https://linuxcommand.org/index.php
https://overthewire.org/wargames/
[hat tip: https://niiconsulting.com/checkmate/2017/06/a-detail-guide-on-oscp-preparation-from-newbie-to-oscp/]
-------------------------------------------------------------------------------------------------------------------------------------------------------------

How to interpret the /etc/passwd file
-------------------------------------
Credit: https://linuxize.com/post/etc-passwd-file/ --
There are several different authentication schemes that can be used on Linux systems. The most commonly used and standard scheme is to perform authentication against the /etc/passwd and /etc/shadow files.

/etc/passwd is a plain text-based database that contains information for all user accounts on the system. It is owned by root and has 644 permissions . The file can only be modified by root or users with sudo privileges and readable by all system users.

Modifying the /etc/passwd file by hand should be avoided unless you know what you are doing. Always use a command that is designed for the purpose. For example, to modify a user account, use the usermod command, and to add a new user account use the useradd command.

/etc/passwd Format
The /etc/passwd file is a text file with one entry per line, representing a user account. To view the contents of the file, use a text editor or a command such as cat: $ cat /etc/passwd

Usually, the first line describes the root user, followed by the system and normal user accounts. New entries are appended at the end of the file.

Each line of the /etc/passwd file contains seven comma-separated fields:

Output
mark:x:1001:1001:mark,,,:/home/mark:/bin/bash
[--] - [--] [--] [-----] [--------] [--------]
|    |   |    |     |         |        |
|    |   |    |     |         |        +-> 7. Login shell
|    |   |    |     |         +----------> 6. Home directory
|    |   |    |     +--------------------> 5. GECOS
|    |   |    +--------------------------> 4. GID
|    |   +-------------------------------> 3. UID
|    +-----------------------------------> 2. Password
+----------------------------------------> 1. Username

01. Username. The string you type when you log into the system. Each username must be a unique string on the machine. The maximum length of the username is restricted to 32 characters.
02. Password. In older Linux systems, the user’s encrypted password was stored in the /etc/passwd file. On most modern systems, this field is set to x, and the user password is stored in the /etc/shadow file.
03. UID. The user identifier is a number assigned to each user. It is used by the operating system to refer to a user.
04. GID. The user’s group identifier number, referring to the user’s primary group. When a user creates a file , the file’s group is set to this group. Typically, the name of the group is the same as the name of the user. User’s secondary groups are listed in the /etc/groups file.
05. GECOS or the full name of the user. This field contains a list of comma-separated values with the following information:
User’s full name or the application name.
 - Room number.
 - Work phone number.
 - Home phone number.
 - Other contact information.
06. Home directory. The absolute path to the user’s home directory. It contains the user’s files and configurations. By default, the user home directories are named after the name of the user and created under the /home directory.
07. Login shell. The absolute path to the user’s login shell. This is the shell that is started when the user logs into the system. On most Linux distributions, the default login shell is Bash.
--Credit: https://linuxize.com/post/etc-passwd-file/
--------------------------------------------------------------------------------------------------------------------------------------------------------
Explain Shell
https://explainshell.com/
"write down a command-line to see the help text that matches each argument"
[hat tip: https://fosspost.org/linux-command-line-basics-examples/
"How To Know What a Linux Command Does?
Since you are a new user, you may see many people passing different Linux commands on the Internet that may do different tasks. But how can you understand what these commands will do on your system if you apply them?
ExplainShell.com is the answer.
Let’s say that you encountered a very long command while browsing an online article or a book, and you didn’t know what does it do and how? Just paste it into the website and it will tell you what each part of it does. It’s an amazing online website to explain Linux commands.]
--------------------------------------------------------------------------------------------------------------------------------------------------------
From: https://flashpoint.io/blog/osint-tools-library/

Manipulate datasets from Terminal
OSINT practitioners frequently run across TXT and CSV files. Often, the formatting for CSV files is not compatible with your investigation and you need to remove certain columns, add others, change column titles, etc. If you’re looking to remove all columns except for a select few, use this trick:

$ cut -d, -f<column number> --complement input.csv > output.csv

Example:

$ cut -d, -f4 --complement osint.csv > oshint.csv

This will remove the fourth column of osint.csv and save it to oshint.csv. If you remove [the] --complement [argument], you’ll remove all columns except for column 4.

To learn more about this Linux command, check out: https://linuxconfig.org/how-to-remove-columns-from-csv-based-on-column-number-using-bash-shell
--------------------------------------------------------------------------------------------------------------------------------------------------------
From: https://medium.com/@halil_tek/the-most-important-linux-commands-that-nobody-teaches-you-1b6919860c8f (with edits ; note: only some of the commands mntioned in the article are copied here)

rsync
-----
Used to copy files and directories to a destination, similar to the cp command. However, it also allows copying to remote locations and can provide a progress bar, as is often used for backups

# Example Usage
$ rsync -vap --ignore-existing <source_file> <destination_file>#  Key flags:
v = verbose, r = recursive, p = preserve permissions, g = group, o = owner, a = archive, --progress = progresss bar


mkpasswd
--------
mkpasswd is a simple but very useful command, it generates a complex random password at the specified length.

$ mkpasswd -l 8
> iwF1g2Lo

screen
-------
Screen is a full-screen window manager; it creates a single window with a shell running and allows multiple screen windows to run inside a single session. It’s most beneficial when you’re running a long task remotely and worried about your SSH session dropping and ruining everything. Screen will continue through disconnection and continue to run your commands even when the window is not visible to you.

# Example Usage
$ screen # Start a screen session
$ screen -ls # List running services
$ screen -r # Attach to session

diff
-----
Diff the Output of any two commands
# Example usage of comparing output of two ls commands$ diff -u <(ls -l /directory/) <(ls -l /directory/) | colordiff

date -d
--------
Convert a Unix (Epoch) timestamp to human-readable format
# Convert Unix timestamp to human readable
$ date -d 1656685875
Fri, 01 Jul 2022 14:31:15 +0000
# Current time as UNIX timestamp
$ date "+%s"
-------------------------------------------------------
Unix Epoch time

"Unix time is a date and time representation widely used in computing. It measures time by the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970, the beginning of the Unix epoch, less adjustments made due to leap seconds. Unix time originated as the system time of Unix operating systems." (Wikipedia)

Epoch Converter
https://www.epochconverter.com/
Epoch & Unix Timestamp [Online] Conversion Tools

"What is epoch time?
The Unix epoch (or Unix time or POSIX time or Unix timestamp) is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (in ISO 8601: 1970-01-01T00:00:00Z). Literally speaking the epoch is Unix time 0 (midnight 1/1/1970), but 'epoch' is often used as a synonym for Unix time. Some systems store epoch dates as a signed 32-bit integer, which might cause problems on January 19, 2038 (known as the Year 2038 problem or Y2038). The converter on this page converts timestamps in seconds (10-digit), milliseconds (13-digit) and microseconds (16-digit) to readable dates.

Human-readable time 	Seconds
1 hour	3600 seconds
1 day	86400 seconds
1 week	604800 seconds
1 month (30.44 days) 	2629743 seconds
1 year (365.24 days) 	 31556926 seconds
How to get the current epoch time in ...
PHP	time() More PHP
Python	import time; time.time() Source
Ruby	Time.now (or Time.new). To display the epoch: Time.now.to_i
Perl	time More Perl
Java	long epoch = System.currentTimeMillis()/1000; Returns epoch in seconds.
C#	DateTimeOffset.Now.ToUnixTimeSeconds() (.NET Framework 4.6+/.NET Core), older versions: var epoch = (DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;
Objective-C	[[NSDate date] timeIntervalSince1970]; (returns double) or NSString *currentTimestamp = [NSString stringWithFormat:@"%f", [[NSDate date] timeIntervalSince1970]];
C++11	double now = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
Lua	epoch = os.time([date])
VBScript/ASP	See the examples
AutoIT	_DateDiff('s', "1970/01/01 00:00:00", _NowCalc())
Delphi	Epoch := DateTimetoUnix(Now); Tested in Delphi 2010.
R	as.numeric(Sys.time())
Erlang/OTP	erlang:system_time(seconds). (version 18+), older versions: calendar:datetime_to_gregorian_seconds(calendar:universal_time())-719528*24*3600.
MySQL	SELECT unix_timestamp(now()) More MySQL examples
PostgreSQL	SELECT extract(epoch FROM now());
SQLite	SELECT strftime('%s', 'now');
Oracle PL/SQL	SELECT (CAST(SYS_EXTRACT_UTC(SYSTIMESTAMP) AS DATE) - TO_DATE('01/01/1970','DD/MM/YYYY')) * 24 * 60 * 60 FROM DUAL;
SQL Server	SELECT DATEDIFF(s, '1970-01-01 00:00:00', GETUTCDATE())
IBM Informix	SELECT dbinfo('utc_current') FROM sysmaster:sysdual;
JavaScript	Math.floor(new Date().getTime()/1000.0) The getTime method returns the time in milliseconds.
Visual FoxPro	DATETIME() - {^1970/01/01 00:00:00} Warning: time zones not handled correctly
Go	time.Now().Unix() More Go 
Adobe ColdFusion	<cfset epochTime = left(getTickcount(), 10)>
Tcl/Tk	clock seconds
Unix/Linux Shell	date +%s
Solaris	/usr/bin/nawk 'BEGIN {print srand()}' Solaris doesn't support date +%s, but the default seed value for nawk's random-number generator is the number of seconds since the epoch.
PowerShell	[int][double]::Parse((Get-Date (get-date).touniversaltime() -UFormat %s))
Other OS's	Command line: perl -e "print time" (If Perl is installed on your system)

Convert from human-readable date to epoch
PHP	strtotime("15 November 2018") (converts most English date texts) or:
date_create('11/15/2018')->format('U') (using DateTime class) More PHP
Python	import calendar, time; calendar.timegm(time.strptime('2000-01-01 12:34:00', '%Y-%m-%d %H:%M:%S'))
Ruby	Time.local(year, month, day, hour, minute, second, usec ) (or Time.gm for GMT/UTC input). To display add .to_i
Perl	Use the Perl Epoch routines
Java	long epoch = new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss").parse("01/01/1970 01:00:00").getTime() / 1000; Timestamp in seconds, remove '/1000' for milliseconds.
VBScript/ASP	DateDiff("s", "01/01/1970 00:00:00", time field) More ASP
AutoIT	_DateDiff('s', "1970/01/01 00:00:00", "YYYY/MM/DD HH:MM:SS")
Delphi	Epoch := DateTimeToUnix(StrToDateTime(myString));
C	Use the C Epoch Converter routines
R	as.numeric(as.POSIXct("YYYY-MM-dd HH:mm:ss", tz = "GMT", origin="1970-01-01")) The origin parameter is optional
Go	Example code 
Rust	SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) 
Adobe ColdFusion	int(parseDateTime(datetime).getTime()/1000);
MySQL	SELECT unix_timestamp(time) Time format: YYYY-MM-DD HH:MM:SS or YYMMDD or YYYYMMDD
More on using Epoch timestamps with MySQL
PostgreSQL	SELECT extract(epoch FROM date('2000-01-01 12:34'));
With timestamp: SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2018-02-16 20:38:40-08');
With interval: SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
SQLite	SELECT strftime('%s',timestring);
SQL Server	SELECT DATEDIFF(s, '1970-01-01 00:00:00', time field)
JavaScript	Use the JavaScript Date object
Unix/Linux Shell	date +%s -d"Jan 1, 1980 00:00:01" Replace '-d' with '-ud' to input in GMT/UTC time.
Convert from epoch to human-readable date
PHP	date(output format, epoch); Output format example: 'r' = RFC 2822 date, more PHP examples
Python	import time; time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.localtime(epoch)) Replace time.localtime with time.gmtime for GMT time. Or using datetime: import datetime; datetime.datetime.utcfromtimestamp(epoch).replace(tzinfo=datetime.timezone.utc)
Ruby	Time.at(epoch)
C#	private string epoch2string(int epoch) {
return new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc).AddSeconds(epoch).ToShortDateString(); }
Perl	Use the Perl Epoch routines
Java	String date = new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new java.util.Date (epoch*1000)); Epoch in seconds, remove '*1000' for milliseconds.
Lua	datestring = os.date([format[,epoch]])
VBScript/ASP	DateAdd("s", epoch, "01/01/1970 00:00:00") More ASP
AutoIT	_DateAdd("s", $EpochSeconds , "1970/01/01 00:00:00")
Delphi	myString := DateTimeToStr(UnixToDateTime(Epoch)); Where Epoch is a signed integer.
C	Use the C Epoch Converter routines
Objective-C	NSDate * myDate = [NSDate dateWithTimeIntervalSince1970:epoch]; NSLog(@"%@", date);
R	as.POSIXct(epoch, origin="1970-01-01", tz="GMT")
Go	Example code 
Adobe ColdFusion	DateAdd("s",epoch,"1/1/1970");
MySQL	FROM_UNIXTIME(epoch, optional output format) Default output format is YYY-MM-DD HH:MM:SS. If you need support for negative timestamps: DATE_FORMAT(DATE_ADD(FROM_UNIXTIME(0), interval -315619200 second),"%Y-%m-%d") (replace -315619200 with epoch) More MySQL
PostgreSQL	PostgreSQL version 8.1 and higher: SELECT to_timestamp(epoch); Source Older versions: SELECT TIMESTAMP WITH TIME ZONE 'epoch' + epoch * INTERVAL '1 second';
SQLite	SELECT datetime(epoch_to_convert, 'unixepoch'); or local timezone: SELECT datetime(epoch_to_convert, 'unixepoch', 'localtime');
Oracle PL/SQL	SELECT to_date('01-JAN-1970','dd-mon-yyyy')+(1526357743/60/60/24) from dual
Replace 1526357743 with epoch.
SQL Server	DATEADD(s, epoch, '1970-01-01 00:00:00')
IBM Informix	SELECT dbinfo('utc_to_datetime',epoch) FROM sysmaster:sysdual;
Microsoft Excel / LibreOffice Calc	=(A1 / 86400) + 25569 Format the result cell for date/time, the result will be in GMT time (A1 is the cell with the epoch number). For other time zones: =((A1 +/- time zone adjustment) / 86400) + 25569.
Crystal Reports	DateAdd("s", {EpochTimeStampField}-14400, #1/1/1970 00:00:00#) -14400 used for Eastern Standard Time. See Time Zones.
JavaScript	Use the JavaScript Date object
Tcl/Tk	clock format 1325376000 Documentation
MATLAB	datestr(719529+TimeInSeconds/86400,'dd-mmm-yyyy HH:MM:SS')
IBM PureData System for Analytics	select 996673954::int4::abstime::timestamp;
Unix/Linux Shell	date -d @1520000000 Replace 1520000000 with your epoch, needs recent version of 'date'. Replace '-d' with '-ud' for GMT/UTC time.
Mac OS X	date -j -r 1520000000
PowerShell	Function get-epochDate ($epochDate) { [timezone]::CurrentTimeZone.ToLocalTime(([datetime]'1/1/1970').AddSeconds($epochDate)) }, then use: get-epochDate 1520000000. Works for Windows PowerShell v1 and v2
Other OS's	Command line: perl -e "print scalar(localtime(epoch))" (If Perl is installed) Replace 'localtime' with 'gmtime' for GMT/U"
[from: https://www.epochconverter.com/]
--------------------------------------------------------------------------------------------------------------------------------------------------------
Introduction to Named Pipes
https://www.linuxjournal.com/article/2156
