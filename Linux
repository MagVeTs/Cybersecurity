To upgrade/update, write in terminal:

apt update -y && apt upgrade -y && apt dist-upgrade -y

[hat tip: Get Cyber (https://www.youtube.com/watch?v=_mvPASM89a0)

---------------------------------------------------------

In the command line prompt the presence of ~ represents that a user is now in their home directory.
------------------------------------------------

Linux File System
-----------------
* in Linux everything is treated as a file (including devices)
* files are case sensitive
* can contain up to 255 characters
* can contain any character (including whitespace) except /
* extensions are not needed/interpreted; they are only for user convenience

Every file is part of a path - the unique location of the file represented by alphanumeric names of parent directories and the file divided by /
The first / represents root directory and the following slashes delimit nested directories under root and finally the file.

[from: Linux Tutorials | The File System | GeeksforGeeks ; https://www.youtube.com/watch?v=JwgTeXfQdIg&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=5]

In the Linux FHS [File Hierarchy Structure/Filesystem Hierarchy Standard] all files are listed under root (/) even if they are found on different physical/virtual machines.
Only root (/) directory has no parent.
Only the root user can write to the root directory.
The root user's home directory is: /root (note: / != /root)

A "home directory" is the main repository for a user's file's (including their configuration file). When a user logs into a system, by default they usually start off in their home directory. [In the command line prompt the presence of ~ represents that a user is now in their home directory.]
As stated above: the root user's home directory is: /root.
Other users' home directories are by default created with the /home directory.

[from: Linux Tutorials | Linux Directory Structure | GeeksforGeeks ; https://www.youtube.com/watch?v=yWiUPWHljWg&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=6]
--------------------------------------------------------------------------------------------------------------------------------------------------------

Linux CLI
---------

Basics
------

------------------------------------------
Commands must be separated from arguments (e.g. -a) and file names by at least one space or tab; but multiple spaces or tabs is not a problem.
Multiple arguments can be combined in one dash (-) with no spaces, e.g. -l -a -c = -lac
You can run more than one command per line if you use a semicolon (;), e.g.:
> cd;pwd

The 'type' command will tell you where the script for a Linux CLI command (usually written in C language) is found (internal [in the shell itself] or external [in a file path]), for example:
> type ls
ls is hashed (/bin/ls)
> type cd
cd is a shell builtin

[hat tip: Linux Tutorials | Command Usage | GeeksforGeeks https://www.youtube.com/watch?v=L5_ZzpR9jaU&list=PLqM7alHXFySFc4KtwEZTANgmyJm3NqS_L&index=4]
------------------------------------------

[hat tip: https://tryhackme.com/room/zeekbro]

View the command history:
ubuntu@ubuntu$ history

Execute the 10th command in history:
ubuntu@ubuntu$ !10

Execute the previous command:
ubuntu@ubuntu$ !!

Read File
---------
Read sample.txt file:
ubuntu@ubuntu$ cat sample.txt

Read the first 10 lines of the file:
ubuntu@ubuntu$ head sample.txt

Read the last 10 lines of the file:
ubuntu@ubuntu$ tail sample.txt

Find & Filter
-------------
Cut the 1st field:
ubuntu@ubuntu$ cat test.txt | cut -f 1

Cut the 1st column:
ubuntu@ubuntu$ cat test.txt | cut -c1

Filter specific keywords:
ubuntu@ubuntu$ cat test.txt | grep 'keywords'

Sort outputs alphabetically:
ubuntu@ubuntu$ cat test.txt | sort

Sort outputs numerically:
ubuntu@ubuntu$ cat test.txt | sort -n

Eliminate duplicate lines:
ubuntu@ubuntu$ cat test.txt | uniq

Count line numbers:
ubuntu@ubuntu$ cat test.txt | wc -l

Show line numbers
ubuntu@ubuntu$ cat test.txt | nl

Advanced
--------
Print line 11:
ubuntu@ubuntu$ cat test.txt | sed -n '11p'

Print lines between 10-15:
ubuntu@ubuntu$ cat test.txt | sed -n '10,15p'

Print lines below 11:
ubuntu@ubuntu$ cat test.txt | awk 'NR < 11 {print $0}'

Print line 11:
ubuntu@ubuntu$ cat test.txt | awk 'NR == 11 {print $0}'

Use Case	                                           Description
--------                                             ----------- 
sort | uniq                                     Remove duplicate values.

sort | uniq -c                                  Remove duplicates and count the number of occurrences for each value.

sort -nr                                        Sort values numerically and recursively.

rev                                             Reverse string characters.

cut -f 1                                        Cut field 1.

cut -d '.' -f 1-2                               Split the string on every dot and print keep the first two fields.

grep -v 'test'                                  Display lines that  don't match the "test" string.

grep -v -e 'test1' -e 'test2'                   Display lines that don't match one or both "test1" and "test2" strings.

file                                            View file information.

grep -rin Testvalue1 * | column -t | less -S    Search the "Testvalue1" string everywhere, organise column spaces and view the output with less.

[hat tip: https://tryhackme.com/room/zeekbro]
-----------------------------------------------------------------------------------------------------------------------------------------------------------
Use case for "rev" command in Linux CLI:
The rev command reverses the text. So the word "hello" becomes "olleh".
In the TryHackMe room "Zeek Exercises" [https://tryhackme.com/room/zeekbroexercises ; Task 2, Question 3] it was necessary to find all the unique domain names in a file using the CLI.
The CLI can use the "uniq" command to list each unique domain.
The problem is that each domain appeared many times with various sub-domains of varying lengths and textual content. There could also have been sub-sub-domains delineated by ".". How does one tell the computer to only look at the domain and TLD when determing uniqueness?
The hint TryHackMe gave for this question used rev as part of the command. Basically, you reverse the text and then use "cut -d '.' -f 1-2" to pull out only the TLD and domain names. You have avoided the variability in the sub-domains and can be sure that you are only extracting the TLD and domain. Then you rev the data back into the proper order and list each unique occurence.
------------------------------------------------------------------------------------------------------------------------------------------------------------
Learning Linux CLI (aka Terminal aka Bash)
------------------------------------------
https://ubuntu.com/tutorials/command-line-for-beginners#1-overview
https://www.hackthebox.com/blog/learn-linux
https://www.freecodecamp.org/news/the-linux-commands-handbook/
[hat tip: https://www.reddit.com/r/tryhackme -- WRWhizard]
-------------------------------------------------------------------------------------------------------------------------------------------------------------
https://linuxcommand.org/index.php
https://overthewire.org/wargames/
[hat tip: https://niiconsulting.com/checkmate/2017/06/a-detail-guide-on-oscp-preparation-from-newbie-to-oscp/]
-------------------------------------------------------------------------------------------------------------------------------------------------------------

How to interpret the /etc/passwd file
-------------------------------------
Credit: https://linuxize.com/post/etc-passwd-file/ --
There are several different authentication schemes that can be used on Linux systems. The most commonly used and standard scheme is to perform authentication against the /etc/passwd and /etc/shadow files.

/etc/passwd is a plain text-based database that contains information for all user accounts on the system. It is owned by root and has 644 permissions . The file can only be modified by root or users with sudo privileges and readable by all system users.

Modifying the /etc/passwd file by hand should be avoided unless you know what you are doing. Always use a command that is designed for the purpose. For example, to modify a user account, use the usermod command, and to add a new user account use the useradd command.

/etc/passwd Format
The /etc/passwd file is a text file with one entry per line, representing a user account. To view the contents of the file, use a text editor or a command such as cat: $ cat /etc/passwd

Usually, the first line describes the root user, followed by the system and normal user accounts. New entries are appended at the end of the file.

Each line of the /etc/passwd file contains seven comma-separated fields:

Output
mark:x:1001:1001:mark,,,:/home/mark:/bin/bash
[--] - [--] [--] [-----] [--------] [--------]
|    |   |    |     |         |        |
|    |   |    |     |         |        +-> 7. Login shell
|    |   |    |     |         +----------> 6. Home directory
|    |   |    |     +--------------------> 5. GECOS
|    |   |    +--------------------------> 4. GID
|    |   +-------------------------------> 3. UID
|    +-----------------------------------> 2. Password
+----------------------------------------> 1. Username

01. Username. The string you type when you log into the system. Each username must be a unique string on the machine. The maximum length of the username is restricted to 32 characters.
02. Password. In older Linux systems, the user’s encrypted password was stored in the /etc/passwd file. On most modern systems, this field is set to x, and the user password is stored in the /etc/shadow file.
03. UID. The user identifier is a number assigned to each user. It is used by the operating system to refer to a user.
04. GID. The user’s group identifier number, referring to the user’s primary group. When a user creates a file , the file’s group is set to this group. Typically, the name of the group is the same as the name of the user. User’s secondary groups are listed in the /etc/groups file.
05. GECOS or the full name of the user. This field contains a list of comma-separated values with the following information:
User’s full name or the application name.
 - Room number.
 - Work phone number.
 - Home phone number.
 - Other contact information.
06. Home directory. The absolute path to the user’s home directory. It contains the user’s files and configurations. By default, the user home directories are named after the name of the user and created under the /home directory.
07. Login shell. The absolute path to the user’s login shell. This is the shell that is started when the user logs into the system. On most Linux distributions, the default login shell is Bash.
--Credit: https://linuxize.com/post/etc-passwd-file/
--------------------------------------------------------------------------------------------------------------------------------------------------------
Explain Shell
https://explainshell.com/
"write down a command-line to see the help text that matches each argument"
[hat tip: https://fosspost.org/linux-command-line-basics-examples/
"How To Know What a Linux Command Does?
Since you are a new user, you may see many people passing different Linux commands on the Internet that may do different tasks. But how can you understand what these commands will do on your system if you apply them?
ExplainShell.com is the answer.
Let’s say that you encountered a very long command while browsing an online article or a book, and you didn’t know what does it do and how? Just paste it into the website and it will tell you what each part of it does. It’s an amazing online website to explain Linux commands.]
--------------------------------------------------------------------------------------------------------------------------------------------------------
From: https://flashpoint.io/blog/osint-tools-library/

Manipulate datasets from Terminal
OSINT practitioners frequently run across TXT and CSV files. Often, the formatting for CSV files is not compatible with your investigation and you need to remove certain columns, add others, change column titles, etc. If you’re looking to remove all columns except for a select few, use this trick:

$ cut -d, -f<column number> --complement input.csv > output.csv

Example:

$ cut -d, -f4 --complement osint.csv > oshint.csv

This will remove the fourth column of osint.csv and save it to oshint.csv. If you remove [the] --complement [argument], you’ll remove all columns except for column 4.

To learn more about this Linux command, check out: https://linuxconfig.org/how-to-remove-columns-from-csv-based-on-column-number-using-bash-shell
--------------------------------------------------------------------------------------------------------------------------------------------------------
From: https://medium.com/@halil_tek/the-most-important-linux-commands-that-nobody-teaches-you-1b6919860c8f (with edits ; note: only some of the commands mntioned in the article are copied here)

rsync
-----
Used to copy files and directories to a destination, similar to the cp command. However, it also allows copying to remote locations and can provide a progress bar, as is often used for backups

# Example Usage
$ rsync -vap --ignore-existing <source_file> <destination_file>#  Key flags:
v = verbose, r = recursive, p = preserve permissions, g = group, o = owner, a = archive, --progress = progresss bar


mkpasswd
--------
mkpasswd is a simple but very useful command, it generates a complex random password at the specified length.

$ mkpasswd -l 8
> iwF1g2Lo

screen
-------
Screen is a full-screen window manager; it creates a single window with a shell running and allows multiple screen windows to run inside a single session. It’s most beneficial when you’re running a long task remotely and worried about your SSH session dropping and ruining everything. Screen will continue through disconnection and continue to run your commands even when the window is not visible to you.

# Example Usage
$ screen # Start a screen session
$ screen -ls # List running services
$ screen -r # Attach to session

diff
-----
Diff the Output of any two commands
# Example usage of comparing output of two ls commands$ diff -u <(ls -l /directory/) <(ls -l /directory/) | colordiff

date -d
--------
Convert a Unix timestamp to human-readable format
# Convert Unix timestamp to human readable
$ date -d 1656685875
Fri, 01 Jul 2022 14:31:15 +0000
# Current time as UNIX timestamp
$ date "+%s"
--------------------------------------------------------------------------------------------------------------------------------------------------------
Introduction to Named Pipes
https://www.linuxjournal.com/article/2156
